{"version":3,"file":"core.cjs.production.min.js","sources":["../src/reduxStore.ts","../src/dispatcher.ts","../src/rematchStore.ts","../src/config.ts","../src/index.ts","../src/bag.ts"],"sourcesContent":["import * as Redux from 'redux'\nimport {\n\tAction,\n\tConfigRedux,\n\tModelReducers,\n\tNamedModel,\n\tRematchBag,\n\tDevtoolOptions,\n\tModels,\n\tRematchRootState,\n} from './types'\n\n/**\n * Creates 'combined' reducer for each model and then merges those reducers\n * together into a 'root' reducer. It then creates a Redux store with\n * middlewares and enhancers.\n */\nexport default function createReduxStore<TModels extends Models>(\n\tbag: RematchBag\n): Redux.Store<RematchRootState<TModels>> {\n\tfor (const model of bag.models) {\n\t\tcreateModelReducer(bag, model)\n\t}\n\n\tconst rootReducer = createRootReducer<RematchRootState<TModels>>(bag)\n\n\tconst middlewares = Redux.applyMiddleware(...bag.reduxConfig.middlewares)\n\tconst enhancers = composeEnhancersWithDevtools(\n\t\tbag.reduxConfig.devtoolOptions\n\t)(...bag.reduxConfig.enhancers, middlewares)\n\n\tconst createStore = bag.reduxConfig.createStore || Redux.createStore\n\tconst bagInitialState = bag.reduxConfig.initialState\n\tconst initialState = bagInitialState === undefined ? {} : bagInitialState\n\n\treturn createStore<\n\t\tRematchRootState<TModels>,\n\t\tAction,\n\t\tany,\n\t\ttypeof initialState\n\t>(rootReducer, initialState, enhancers)\n}\n\n/**\n * Creates a combined reducer for a given model. What it means is that:\n * - it forms an action name for each model's reducer as 'modelName/reducerKey'\n * - it creates a mapping from action name to its reducer\n * - it wraps the mapping with a function (combined reducer) that selects and\n *   runs a reducer based on the incoming action\n * - if the model also has a base reducer defined, it creates a function which\n *   first runs the incoming action through this reducer and then passes the\n *   resulting state and the same action to combined reducer\n *\n * The final result - a function, is returned.\n */\nexport function createModelReducer<\n\tTModel extends NamedModel,\n\tTState extends TModel['state']\n>(bag: RematchBag, model: TModel): void {\n\tconst modelReducers: ModelReducers<TState> = {}\n\n\t// build action name for each reducer and create mapping from name to reducer\n\tfor (const reducerKey of Object.keys(model.reducers)) {\n\t\tconst actionName = isAlreadyActionName(reducerKey)\n\t\t\t? reducerKey\n\t\t\t: `${model.name}/${reducerKey}`\n\n\t\tmodelReducers[actionName] = model.reducers[reducerKey]\n\t}\n\n\t// select and run a reducer based on the incoming action\n\tconst combinedReducer = (\n\t\tstate: TState = model.state,\n\t\taction: Action\n\t): TState => {\n\t\tif (action.type in modelReducers) {\n\t\t\treturn modelReducers[action.type](state, action.payload)\n\t\t}\n\n\t\treturn state\n\t}\n\n\tconst modelBaseReducer = model.baseReducer\n\n\t// when baseReducer is defined, run the action first through it\n\tlet reducer = !modelBaseReducer\n\t\t? combinedReducer\n\t\t: (state: TState = model.state, action: Action): TState =>\n\t\t\t\tcombinedReducer(modelBaseReducer(state, action), action)\n\n\tbag.forEachPlugin('onReducer', (onReducer) => {\n\t\treducer = onReducer(reducer, model.name, bag) || reducer\n\t})\n\n\tbag.reduxConfig.reducers[model.name] = reducer\n}\n\n/**\n * It merges all reducers in config using mergeReducers function. Additionally,\n * if user supplied any rootReducers, a wrapper function around merged reducers\n * is created. It first feeds each into its corresponding 'root' reducer (if\n * it's available), and then passes on the resulting state to the merged reducer.\n */\nexport function createRootReducer<TRootState>(\n\tbag: RematchBag\n): Redux.Reducer<TRootState, Action> {\n\tconst { rootReducers } = bag.reduxConfig\n\tconst mergedReducers = mergeReducers<TRootState>(bag.reduxConfig)\n\tlet rootReducer = mergedReducers\n\n\tif (rootReducers && Object.keys(rootReducers).length) {\n\t\trootReducer = (\n\t\t\tstate: TRootState | undefined,\n\t\t\taction: Action\n\t\t): TRootState => {\n\t\t\tconst actionRootReducer = rootReducers[action.type]\n\n\t\t\tif (actionRootReducer) {\n\t\t\t\treturn mergedReducers(actionRootReducer(state, action), action)\n\t\t\t}\n\n\t\t\treturn mergedReducers(state, action)\n\t\t}\n\t}\n\n\tbag.forEachPlugin('onRootReducer', (onRootReducer) => {\n\t\trootReducer = onRootReducer(rootReducer, bag) || rootReducer\n\t})\n\n\treturn rootReducer\n}\n\n/**\n * Merges all reducers defined in config into one function using user supplied\n * or default combineReducers function.\n * If there are no reducers defined, it returns a function that just returns\n * the state for all incoming actions.\n */\nfunction mergeReducers<TRootState>(\n\treduxConfig: ConfigRedux<TRootState>\n): Redux.Reducer<TRootState, Action> {\n\tconst combineReducers = reduxConfig.combineReducers || Redux.combineReducers\n\n\tif (!Object.keys(reduxConfig.reducers).length) {\n\t\treturn (state: any): TRootState => state\n\t}\n\n\treturn combineReducers(reduxConfig.reducers as Redux.ReducersMapObject)\n}\n\n/**\n * Returns Redux Devtools compose method unless it's disabled, in which case it\n * returns default Redux.compose.\n */\nfunction composeEnhancersWithDevtools(\n\tdevtoolOptions: DevtoolOptions = {}\n): (...args: any[]) => Redux.StoreEnhancer {\n\tconst { disabled, ...options } = devtoolOptions\n\n\treturn !disabled &&\n\t\ttypeof window === 'object' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(options)\n\t\t: Redux.compose\n}\n\n/**\n * Determines if a reducer key is already an action name, for example -\n * a listener on another model.\n */\nfunction isAlreadyActionName(reducerKey: string): boolean {\n\treturn reducerKey.indexOf('/') > -1\n}\n","/* eslint-disable @typescript-eslint/ban-ts-ignore */\nimport {\n\tAction,\n\tModelDispatcher,\n\tModelEffects,\n\tModelEffectsCreator,\n\tModels,\n\tNamedModel,\n\tRematchBag,\n\tRematchDispatcher,\n\tEffectRematchDispatcher,\n\tRematchStore,\n} from './types'\nimport { validateModelEffect, validateModelReducer } from './validate'\n\n/**\n * Builds a dispatcher for given model name and action name. The dispatched\n * action will have a type `modelName/actionName`.\n * Additionally, adds the isEffect property to the created dispatcher.\n * isEffect helps to differentiate effects dispatchers from reducer dispatchers.\n */\nconst createActionDispatcher = <TModels extends Models>(\n\trematch: RematchStore<TModels>,\n\tmodelName: string,\n\tactionName: string,\n\tisEffect: boolean\n): RematchDispatcher | EffectRematchDispatcher => {\n\treturn Object.assign(\n\t\t(payload?: any): Action => {\n\t\t\tconst action: Action = { type: `${modelName}/${actionName}` }\n\n\t\t\tif (typeof payload !== 'undefined') {\n\t\t\t\taction.payload = payload\n\t\t\t}\n\n\t\t\treturn rematch.dispatch(action)\n\t\t},\n\t\t{\n\t\t\tisEffect,\n\t\t}\n\t)\n}\n\n/**\n * Creates a dispatcher object for a model - it contains a mapping from all\n * reducers and effects *names* to functions which dispatch their corresponding\n * actions.\n */\nconst createDispatcher = <TModels extends Models, TModel extends NamedModel>(\n\trematch: RematchStore<TModels>,\n\tbag: RematchBag,\n\tmodel: TModel\n): ModelDispatcher<TModel, TModels> => {\n\tconst modelDispatcher = {} as ModelDispatcher<TModel, TModels>\n\n\t// map reducer names to dispatch actions\n\tfor (const reducerName of Object.keys(model.reducers)) {\n\t\tvalidateModelReducer(model.name, model.reducers, reducerName)\n\n\t\t// @ts-ignore\n\t\tmodelDispatcher[reducerName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\treducerName,\n\t\t\tfalse\n\t\t)\n\t}\n\n\tlet effects: ModelEffects = {}\n\n\t// 'effects' might be actually a function creating effects\n\tif (model.effects) {\n\t\teffects =\n\t\t\ttypeof model.effects === 'function'\n\t\t\t\t? (model.effects as ModelEffectsCreator<TModels>)(rematch.dispatch)\n\t\t\t\t: model.effects\n\t}\n\n\t// map effects names to dispatch actions\n\tfor (const effectName of Object.keys(effects)) {\n\t\tvalidateModelEffect(model.name, effects, effectName)\n\n\t\t// @ts-ignore\n\t\tbag.effects[`${model.name}/${effectName}`] = effects[effectName].bind(\n\t\t\t// @ts-ignore\n\t\t\tmodelDispatcher\n\t\t)\n\n\t\t// @ts-ignore\n\t\tmodelDispatcher[effectName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\teffectName,\n\t\t\ttrue\n\t\t)\n\t}\n\n\treturn modelDispatcher\n}\n\nexport default createDispatcher\n","/* eslint-disable @typescript-eslint/ban-ts-ignore */\nimport { Middleware } from 'redux'\nimport {\n\tAction,\n\tConfig,\n\tExposedFunction,\n\tModels,\n\tNamedModel,\n\tObjectNotAFunction,\n\tPlugin,\n\tRematchBag,\n\tRematchStore,\n} from './types'\nimport createReduxStore, {\n\tcreateModelReducer,\n\tcreateRootReducer,\n} from './reduxStore'\nimport createDispatcher from './dispatcher'\nimport { validateModel } from './validate'\nimport createRematchBag from './bag'\n\nexport default function createRematchStore<\n\tTModels extends Models,\n\tTExtraModels extends Models\n>(config: Config<TModels>): RematchStore<TModels & TExtraModels> {\n\t// setup rematch 'bag' for storing useful values and functions\n\tconst bag = createRematchBag(config)\n\n\t// add middleware for handling effects\n\tbag.reduxConfig.middlewares.push(createEffectsMiddleware(bag))\n\n\t// collect middlewares from plugins\n\tbag.forEachPlugin('createMiddleware', (createMiddleware) => {\n\t\tbag.reduxConfig.middlewares.push(createMiddleware(bag))\n\t})\n\n\tconst reduxStore = createReduxStore(bag)\n\n\tlet rematchStore = {\n\t\t...reduxStore,\n\t\tname: config.name,\n\t\taddModel(model: NamedModel) {\n\t\t\tvalidateModel(model)\n\t\t\tcreateModelReducer(bag, model)\n\t\t\tprepareModel<TModels & TExtraModels, typeof model>(this, bag, model)\n\t\t\tthis.replaceReducer(createRootReducer(bag))\n\t\t\treduxStore.dispatch({ type: '@@redux/REPLACE' })\n\t\t},\n\t} as RematchStore<TModels & TExtraModels>\n\n\taddExposed(rematchStore, config.plugins)\n\n\trematchStore.addModel.bind(rematchStore)\n\n\t// generate dispatch[modelName][actionName] for all reducers and effects\n\tfor (const model of bag.models) {\n\t\tprepareModel<TModels & TExtraModels, typeof model>(rematchStore, bag, model)\n\t}\n\n\tbag.forEachPlugin('onStoreCreated', (onStoreCreated) => {\n\t\trematchStore = onStoreCreated(rematchStore, bag) || rematchStore\n\t})\n\n\treturn rematchStore\n}\n\nfunction createEffectsMiddleware(bag: RematchBag): Middleware {\n\treturn (store) => (next) => (action: Action): any => {\n\t\tif (action.type in bag.effects) {\n\t\t\t// first run reducer action if exists\n\t\t\tnext(action)\n\n\t\t\t// then run the effect and return its result\n\t\t\t// @ts-ignore\n\t\t\treturn bag.effects[action.type](action.payload, store.getState())\n\t\t}\n\n\t\treturn next(action)\n\t}\n}\n\nfunction prepareModel<TModels extends Models, TModel extends NamedModel>(\n\trematchStore: RematchStore<TModels>,\n\tbag: RematchBag,\n\tmodel: TModel\n): void {\n\t// @ts-ignore\n\trematchStore.dispatch[model.name] = createDispatcher<TModels, TModel>(\n\t\trematchStore,\n\t\tbag,\n\t\tmodel\n\t)\n\n\tbag.forEachPlugin('onModel', (onModel) => onModel(model, rematchStore))\n}\n\n/**\n * Adds properties exposed by plugins into the Rematch instance. If a exposed\n * property is a function, it passes rematch as the first argument.\n *\n * If you're implementing a plugin in TypeScript, extend Rematch namespace by\n * adding the properties that you exposed from your plugin.\n */\nfunction addExposed(store: RematchStore<any>, plugins: Plugin[]): void {\n\tfor (const plugin of plugins) {\n\t\tif (plugin.exposed) {\n\t\t\tfor (const key of Object.keys(plugin.exposed)) {\n\t\t\t\tconst exposedItem = plugin.exposed[key] as\n\t\t\t\t\t| ExposedFunction\n\t\t\t\t\t| ObjectNotAFunction\n\t\t\t\tconst isExposedFunction = typeof exposedItem === 'function'\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tstore[key] = isExposedFunction\n\t\t\t\t\t? (...params: any[]): any =>\n\t\t\t\t\t\t\t(exposedItem as ExposedFunction)(store, ...params)\n\t\t\t\t\t: Object.create(plugin.exposed[key])\n\t\t\t}\n\t\t}\n\t}\n}\n","import { InitConfig, Config, Models } from './types'\nimport { validateConfig, validatePlugin } from './validate'\n\nlet count = 0\n\n/**\n * Builds complete Rematch config using default values for properties not\n * supplied by the user. Additionally, applies changes to the config made by\n * the plugins selected by the user.\n */\nexport default function createConfig<TModels extends Models>(\n\tinitConfig: InitConfig<TModels>\n): Config<TModels> {\n\tconst storeName = initConfig.name ?? `Rematch Store ${count}`\n\n\tcount += 1\n\n\tconst config = {\n\t\tname: storeName,\n\t\tmodels: initConfig.models || ({} as TModels),\n\t\tplugins: initConfig.plugins || [],\n\t\tredux: {\n\t\t\treducers: {},\n\t\t\trootReducers: {},\n\t\t\tenhancers: [],\n\t\t\tmiddlewares: [],\n\t\t\t...initConfig.redux,\n\t\t\tdevtoolOptions: {\n\t\t\t\tname: storeName,\n\t\t\t\t...(initConfig.redux?.devtoolOptions ?? {}),\n\t\t\t},\n\t\t},\n\t} as Config<TModels>\n\n\tvalidateConfig(config)\n\n\t// Apply changes to the config required by plugins\n\tfor (const plugin of config.plugins) {\n\t\tif (plugin.config) {\n\t\t\t// Collect new models\n\t\t\tconfig.models = merge(config.models, plugin.config.models)\n\n\t\t\t// Collect redux configuration changes\n\t\t\tif (plugin.config.redux) {\n\t\t\t\tconfig.redux.initialState = merge(\n\t\t\t\t\tconfig.redux.initialState,\n\t\t\t\t\tplugin.config.redux.initialState\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.reducers = merge(\n\t\t\t\t\tconfig.redux.reducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.rootReducers = merge(\n\t\t\t\t\tconfig.redux.rootReducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.enhancers = [\n\t\t\t\t\t...config.redux.enhancers,\n\t\t\t\t\t...(plugin.config.redux.enhancers || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.middlewares = [\n\t\t\t\t\t...config.redux.middlewares,\n\t\t\t\t\t...(plugin.config.redux.middlewares || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.combineReducers =\n\t\t\t\t\tconfig.redux.combineReducers || plugin.config.redux.combineReducers\n\n\t\t\t\tconfig.redux.createStore =\n\t\t\t\t\tconfig.redux.createStore || plugin.config.redux.createStore\n\t\t\t}\n\t\t}\n\n\t\tvalidatePlugin(plugin)\n\t}\n\n\treturn config\n}\n\n/**\n * Shallow merges original object with the extra object, giving the precedence\n * to the original object.\n */\nfunction merge<T extends object>(original: T, extra: T | undefined): T {\n\treturn extra ? { ...extra, ...original } : original\n}\n","import { Reducer as ReduxReducer } from 'redux'\nimport createRematchStore from './rematchStore'\nimport {\n\tInitConfig,\n\tModels,\n\tRematchStore,\n\tModelReducers,\n\tModelEffects,\n\tModelEffectsCreator,\n\tRematchDispatch,\n} from './types'\nimport createConfig from './config'\n\n/**\n * Patch for the incompatibility between Redux.Dispatch and RematchDispatch\n */\ndeclare module 'react-redux' {\n\tinterface Connect {\n\t\t<\n\t\t\tRM extends Models<RM> = Models,\n\t\t\tState = DefaultRootState,\n\t\t\tTStateProps = {},\n\t\t\tTDispatchProps = {},\n\t\t\tTOwnProps = {}\n\t\t>(\n\t\t\tmapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n\t\t\tmapDispatchToProps: MapRematchDispatchToPropsNonObject<\n\t\t\t\tTDispatchProps,\n\t\t\t\tTOwnProps,\n\t\t\t\tRM\n\t\t\t>\n\t\t): InferableComponentEnhancerWithProps<\n\t\t\tTStateProps & TDispatchProps,\n\t\t\tTOwnProps\n\t\t>\n\t}\n\n\ttype MapRematchDispatchToPropsNonObject<\n\t\tTDispatchProps,\n\t\tTOwnProps,\n\t\tRM extends Models<RM> = Models\n\t> =\n\t\t| MapRematchDispatchToPropsFactory<TDispatchProps, TOwnProps, RM>\n\t\t| MapRematchDispatchToPropsFunction<TDispatchProps, TOwnProps, RM>\n\n\ttype MapRematchDispatchToPropsFactory<\n\t\tTDispatchProps,\n\t\tTOwnProps,\n\t\tRM extends Models<RM> = Models\n\t> = (\n\t\tdispatch: RematchDispatch<RM>,\n\t\townProps: TOwnProps\n\t) => MapRematchDispatchToPropsFunction<TDispatchProps, TOwnProps, RM>\n\n\ttype MapRematchDispatchToPropsFunction<\n\t\tTDispatchProps,\n\t\tTOwnProps,\n\t\tRM extends Models<RM> = Models\n\t> = (dispatch: RematchDispatch<RM>, ownProps: TOwnProps) => TDispatchProps\n}\n\n/**\n * Prepares a complete configuration and creates a Rematch store.\n */\nexport const init = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models\n>(\n\tinitConfig?: InitConfig<TModels>\n): RematchStore<TModels & TExtraModels> => {\n\tconst config = createConfig(initConfig || {})\n\treturn createRematchStore<TModels, TExtraModels>(config)\n}\n\nexport const createModel: <RM extends Models<RM>>() => <\n\tR extends ModelReducers<S>,\n\tBR extends ReduxReducer<BS>,\n\tE extends ModelEffects | ModelEffectsCreator<RM>,\n\tS,\n\tBS = S\n>(mo: {\n\tname?: string\n\tstate: S\n\treducers?: R\n\tbaseReducer?: BR\n\teffects?: E\n}) => {\n\tname?: string\n\tstate: S\n\treducers: R\n\tbaseReducer: BR\n\teffects: E\n} = () => (mo): any => mo\n\nexport default {\n\tinit,\n\tcreateModel,\n}\n\nexport * from './types'\n","import {\n\tConfig,\n\tModel,\n\tModels,\n\tNamedModel,\n\tPluginHooks,\n\tRematchBag,\n} from './types'\nimport { validateModel } from './validate'\n\n/**\n * Creates and returns a 'Rematch Bag', which is a set of configuration options\n * used by the Rematch library in various functions.\n */\nexport default function createRematchBag<TModels extends Models>(\n\tconfig: Config<TModels>\n): RematchBag {\n\treturn {\n\t\tmodels: createNamedModels(config.models),\n\t\treduxConfig: config.redux,\n\t\tforEachPlugin<Hook extends keyof PluginHooks>(\n\t\t\tmethod: Hook,\n\t\t\tfn: (content: NonNullable<PluginHooks[Hook]>) => void\n\t\t): void {\n\t\t\tfor (const plugin of config.plugins) {\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tfn(plugin[method] as NonNullable<PluginHooks[Hook]>)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\teffects: {},\n\t}\n}\n\n/**\n * Transforms mapping from a model name to a model object, into an array of\n * 'named' models - models with embedded name and default value for reducers\n * if user didn't provide any.\n */\nfunction createNamedModels<M extends Models>(models: M): NamedModel[] {\n\treturn Object.keys(models).map((modelName: string) => {\n\t\tconst model = createNamedModel(modelName, models[modelName])\n\t\tvalidateModel(model)\n\t\treturn model\n\t})\n}\n\n/**\n * Transforms a model into 'named' model - model which contains 'name' and\n * 'reducers' properties if user didn't provide any.\n */\nfunction createNamedModel(name: string, model: Model): NamedModel {\n\treturn {\n\t\tname,\n\t\treducers: {},\n\t\t...model,\n\t}\n}\n"],"names":["createModelReducer","bag","model","modelReducers","Object","keys","reducers","reducerKey","actionName","isAlreadyActionName","name","combinedReducer","state","action","type","payload","modelBaseReducer","baseReducer","reducer","forEachPlugin","onReducer","reduxConfig","createRootReducer","combineReducers","rootReducers","mergedReducers","Redux","length","rootReducer","actionRootReducer","onRootReducer","indexOf","createActionDispatcher","rematch","modelName","isEffect","assign","dispatch","prepareModel","rematchStore","modelDispatcher","reducerName","effects","effectName","bind","createDispatcher","onModel","count","merge","original","extra","init","initConfig","config","models","map","redux","method","fn","plugins","plugin","createRematchBag","middlewares","push","store","next","getState","createEffectsMiddleware","createMiddleware","reduxStore","enhancers","devtoolOptions","disabled","options","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","composeEnhancersWithDevtools","bagInitialState","initialState","createStore","undefined","createReduxStore","addModel","this","replaceReducer","exposed","key","exposedItem","params","create","addExposed","onStoreCreated","createRematchStore","storeName","_initConfig$redux","createConfig","createModel","mo"],"mappings":"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"}