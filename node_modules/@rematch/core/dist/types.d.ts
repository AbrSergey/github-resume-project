import { Action as ReduxAction, Reducer as ReduxReducer, Dispatch as ReduxDispatch, ReducersMapObject, Middleware, StoreEnhancer, StoreCreator, Store as ReduxStore } from 'redux';
export interface Action<TPayload = any> extends ReduxAction<string> {
    payload?: TPayload;
}
export declare type Reducer<TState = any> = (state: TState, payload?: Action['payload']) => TState;
export interface Models<TModels extends Models<TModels> = any> {
    [key: string]: Model<TModels>;
}
export interface NamedModel<TModels extends Models<TModels> = Models, TState = any, TBaseState = TState> extends Model<TModels, TState, TBaseState> {
    name: string;
    reducers: ModelReducers<TState>;
}
export interface Model<TModels extends Models<TModels> = Models, TState = any, TBaseState = TState> {
    name?: string;
    state: TState;
    reducers?: ModelReducers<TState>;
    baseReducer?: ReduxReducer<TBaseState>;
    effects?: ModelEffects | ModelEffectsCreator<TModels>;
}
export declare type ModelReducers<TState = any> = {
    [key: string]: Reducer<TState>;
};
export interface ModelEffects {
    [key: string]: ModelEffect;
}
export declare type ModelEffect = <TModels extends Models<TModels>>(payload: Action['payload'], rootState: RematchRootState<TModels>) => any;
export declare type ModelEffectsCreator<TModels extends Models<TModels>> = (dispatch: RematchDispatch<TModels>) => ModelEffects;
export interface PluginConfig<TExposedModels extends Models> {
    models?: TExposedModels;
    redux?: InitConfigRedux;
}
export interface Plugin<TExposedModels extends Models = any> extends PluginHooks {
    config?: PluginConfig<TExposedModels>;
    exposed?: PluginExposed;
}
export interface PluginHooks {
    onStoreCreated?: StoreCreatedHook;
    onModel?: ModelHook;
    onReducer?: ReducerHook;
    onRootReducer?: RootReducerHook;
    createMiddleware?: MiddlewareCreator;
}
export declare type ModelHook = (model: NamedModel, rematch: RematchStore<any>) => void;
export declare type ReducerHook = (reducer: ReduxReducer, modelName: string, rematch: RematchBag) => ReduxReducer | void;
export declare type RootReducerHook = (reducer: ReduxReducer, rematch: RematchBag) => ReduxReducer | void;
export declare type StoreCreatedHook<TModels extends Models<TModels> = any> = (store: RematchStore<TModels>, rematch: RematchBag) => RematchStore<TModels> | void;
export declare type MiddlewareCreator = (rematch: RematchBag) => Middleware;
export declare type ObjectNotAFunction = {
    [k: string]: any;
} & ({
    bind?: never;
} | {
    call?: never;
});
export declare type PluginExposed = {
    [key: string]: ExposedFunction | ObjectNotAFunction;
};
export declare type ExposedFunction = (rematch: RematchStore<any>, ...args: any) => any;
export interface RematchBag {
    models: NamedModel[];
    reduxConfig: ConfigRedux;
    forEachPlugin: <Hook extends keyof PluginHooks>(method: Hook, fn: (content: NonNullable<PluginHooks[Hook]>) => void) => void;
    effects: ModelEffects;
}
export interface InitConfig<TModels extends Models<TModels>> {
    name?: string;
    models?: TModels;
    plugins?: Plugin[];
    redux?: InitConfigRedux;
}
export interface Config<TModels extends Models<TModels>> extends InitConfig<TModels> {
    name: string;
    models: TModels;
    plugins: Plugin[];
    redux: ConfigRedux;
}
export interface InitConfigRedux<TRootState = any> {
    initialState?: TRootState;
    reducers?: ModelReducers<TRootState>;
    enhancers?: StoreEnhancer[];
    middlewares?: Middleware[];
    rootReducers?: ReducersMapObject<TRootState, Action>;
    combineReducers?: (reducers: ReducersMapObject<TRootState, Action>) => ReduxReducer<TRootState>;
    createStore?: StoreCreator;
    devtoolOptions?: DevtoolOptions;
}
export interface ConfigRedux<TRootState = any> extends InitConfigRedux<TRootState> {
    reducers: ModelReducers<TRootState>;
    enhancers: StoreEnhancer[];
    middlewares: Middleware[];
    rootReducers: ReducersMapObject<TRootState, Action>;
}
export interface RematchStore<TModels extends Models<TModels>> extends ReduxStore<RematchRootState<TModels>, Action> {
    name: string;
    dispatch: RematchDispatch<TModels>;
    addModel: (model: NamedModel) => void;
}
export declare type RematchRootState<TModels extends Models<TModels>> = ExtractRematchStateFromModels<TModels>;
export declare type ExtractRematchStateFromModels<TModels extends Models<TModels>> = {
    [modelKey in keyof TModels]: TModels[modelKey]['state'];
};
export declare type RematchDispatch<TModels extends Models<TModels>> = ReduxDispatch & ExtractRematchDispatchersFromModels<TModels>;
export declare type ExtractRematchDispatchersFromModels<TModels extends Models<TModels>> = {
    [modelKey in keyof TModels]: TModels[modelKey] extends Model<TModels> ? ModelDispatcher<TModels[modelKey], TModels> : never;
};
export declare type ModelDispatcher<TModel extends Model<TModels>, TModels extends Models<TModels>> = ExtractRematchDispatchersFromReducers<TModel['state'], TModel['reducers']> & ExtractRematchDispatchersFromEffects<TModel['effects'], TModels>;
export declare type ExtractRematchDispatchersFromReducers<TState, TReducers extends Model<Models, TState>['reducers']> = {
    [reducerKey in keyof TReducers]: ExtractRematchDispatcherFromReducer<TState, TReducers[reducerKey]>;
};
export declare type ExtractRematchDispatcherFromReducer<TState, TReducer> = TReducer extends () => any ? RematchDispatcher : TReducer extends (state: TState) => TState ? RematchDispatcher : TReducer extends (state: TState, payload: infer TPayload) => TState ? RematchDispatcher<TPayload> : never;
export declare type RematchDispatcher<TPayload = void> = [TPayload] extends [void] ? (() => Action<void>) & {
    isEffect: false;
} : ((payload: TPayload) => Action<TPayload>) & {
    isEffect: false;
};
export declare type ExtractRematchDispatchersFromEffects<TEffects extends Model<TModels>['effects'], TModels extends Models<TModels>> = TEffects extends (...args: any[]) => infer R ? R extends ModelEffects ? ExtractRematchDispatchersFromEffectsObject<R> : never : TEffects extends ModelEffects ? ExtractRematchDispatchersFromEffectsObject<TEffects> : void;
export declare type ExtractRematchDispatchersFromEffectsObject<TEffects extends ModelEffects> = {
    [effectKey in keyof TEffects]: ExtractRematchDispatcherFromEffect<TEffects[effectKey]>;
};
export declare type ExtractRematchDispatcherFromEffect<TEffect extends ModelEffect> = TEffect extends () => infer TReturn ? EffectRematchDispatcher<TReturn> : TEffect extends (payload: infer TPayload) => infer TReturn ? EffectRematchDispatcher<TReturn, TPayload> : TEffect extends (payload: infer TPayload, state: any) => infer TReturn ? EffectRematchDispatcher<TReturn, TPayload> : never;
export declare type EffectRematchDispatcher<TReturn = any, TPayload = void> = [TPayload] extends [void] ? (() => TReturn) & {
    isEffect: true;
} : ((payload: TPayload) => TReturn) & {
    isEffect: true;
};
export interface DevtoolOptions {
    disabled?: boolean;
    [key: string]: any;
}
declare module 'redux' {
    interface Dispatch<A extends Action = AnyAction> {
        [modelName: string]: any;
    }
}
declare global {
    interface Window {
        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: any;
    }
}
//# sourceMappingURL=types.d.ts.map